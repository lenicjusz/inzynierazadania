# inzynierazadania
W zadaniu 1, należało napisać dwie funkcje: symbolic_to_numeric oraz numeric_to_symbolic, które przekształcają zapis uprawnień zgodnie z regułami systemu Unix. Głównym problemem była konwersja znaków r, w, x i - na odpowiadające im wartości liczbowe (4, 2, 1, 0) oraz poprawne zsumowanie ich w trójkach. W przypadku konwersji odwrotnej należało zastosować operacje bitowe, aby z wartości numerycznej odtworzyć ciąg znaków symbolicznych. Wymagana była również dokładna walidacja danych – zarówno długości łańcucha, jak i poprawności znaków. Dla zapewnienia poprawności działania funkcji opracowano testy jednostkowe, które obejmowały przypadki poprawne, graniczne oraz błędne dane wejściowe.

W zadaniu 2, rozszerzono działanie funkcji o możliwość uruchamiania programu z poziomu linii poleceń. Należało stworzyć prosty interfejs przyjmujący argumenty (-s dla trybu symbolicznego i -n dla numerycznego). Główne wyzwanie polegało na tym, by obsłużyć sytuacje, w których użytkownik podał niewłaściwe argumenty (np. oba na raz lub żaden), oraz zapewnić czytelne komunikaty błędów. Zastosowano do tego bibliotekę argparse, która umożliwiła budowę przejrzystego i odpornego na błędy interfejsu tekstowego. Komunikaty o błędach były przekazywane przez stderr, a program kończył działanie z odpowiednim kodem wyjścia.

W zadaniu 3 należało stworzyć aplikację z graficznym interfejsem użytkownika przy użyciu biblioteki Tkinter. Głównym problemem w tym przypadku było zsynchronizowanie dwóch pól formularza – jednego dla trybu symbolicznego, drugiego dla numerycznego – tak, aby zmiana w jednym automatycznie aktualizowała drugie. Do śledzenia zmian zastosowano mechanizm trace_add w zmiennych StringVar, a do uniknięcia zapętleń w aktualizacji użyto tymczasowej flagi blokującej. Dodatkowo, aplikacja sygnalizowała błędy użytkownika poprzez zmianę koloru pola oraz wyświetlanie komunikatu w interfejsie. To rozwiązanie poprawiało interaktywność i użyteczność aplikacji, zapewniając natychmiastową informację zwrotną o poprawności danych.

Podsumowując, każde z trzech zadań stawiało inne wyzwania: pierwsze koncentrowało się na poprawnej logice konwersji i testowaniu, drugie na interfejsie tekstowym i walidacji argumentów, a trzecie na synchronizacji danych i interakcji w interfejsie graficznym.
